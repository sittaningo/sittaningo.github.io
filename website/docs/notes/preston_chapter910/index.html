<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Shingo Nitta">
<meta name="dcterms.date" content="2024-09-12">

<title>Shingo Nitta - 人口学勉強会購読資料(9, 10章)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../{{< fluent animal-turtle-20-regular >}}" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Shingo Nitta</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html" rel="" target="">
 <span class="menu-text">HOME</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../profile/index.html" rel="" target="">
 <span class="menu-text">PROFILE</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research/index.html" rel="" target="">
 <span class="menu-text">RESEARCH</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/index.html" rel="" target="">
 <span class="menu-text">NOTES</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">人口学勉強会購読資料(9, 10章)</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Shingo Nitta </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 12, 2024</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<div class="callout callout-style-simple callout-none no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
購読文献
</div>
</div>
<div class="callout-body-container callout-body">
<p>Preston, Samuel H, Patrick Heuveline, and Michel Guillot. 2000. <em>Demography: Measuring and Modeling Population Processes</em>, Blackwell Publishing.</p>
</div>
</div>
<section id="人口動態事象における年齢パターンをモデリングする" class="level1" data-number="9">
<h1 data-number="9"><span class="header-section-number">9</span> 人口動態事象における年齢パターンをモデリングする</h1>
<p>これまでは年齢をいくつかのかたまり（5歳刻みなど）でまとめてきたが、それは各年齢内の同質性を仮定している。非集約化は人口動態事象を正確に表現することが必要だけれども、結果は煩雑となる。年齢による人口動態事象の年齢パターンをモデリングすることは4つの目的と対応している。</p>
<ol type="1">
<li><p>標準的なパターンを表すモデルと実際のデータとを比較することで、実際のデータの特異性を特定することができる。</p></li>
<li><p>6章でおこなった人口投影のタスクを単純化できる。年齢固有の出生率や死亡率などにたいする個別の仮定を用意する代わりに、モデルの年齢パターンを用いることで、はるかに少ない仮定のもと年齢固有率を算出できる。</p></li>
<li><p>モデルパターンを通して比較的少ないパラメータの値を求め、人口学的パラメータを間接的に推定できる。</p></li>
<li><p>多くの人口に共通する経験的な規則性を発見することで、そのばらつきの規定要因などについての洞察が得られるようになる。</p></li>
</ol>
<p>年齢パターンのモデリングは(1) 年齢のばらつきをリスクとして定式化することで要約する、(2) 平均余命のような指標を年齢固有率の全表を提示する、(3) 1および2の組み合わせの3つのバリエーションがある。</p>
<section id="死亡の年齢パターンのモデル" class="level2" data-number="9.1">
<h2 data-number="9.1" class="anchored" data-anchor-id="死亡の年齢パターンのモデル"><span class="header-section-number">9.1</span> 死亡の年齢パターンのモデル</h2>
<section id="数学的表現" class="level3" data-number="9.1.1">
<h3 data-number="9.1.1" class="anchored" data-anchor-id="数学的表現"><span class="header-section-number">9.1.1</span> 数学的表現</h3>
<p>古典的に死亡の年齢パターンとして死亡率の対数が年齢と線形な関係にあることが知られている(ゴンペルツ曲線)。 <span class="math display">\[
\mu (x) = \alpha \cdot e^{\beta x} \tag{9.1}
\]</span></p>
<p><span class="math display">\[
In [\mu (x)] = In(\alpha) \beta x \tag{ns1}\label{eq:ns1}
\]</span></p>
<p>ただし <span class="math inline">\(\ref{eq:ns1}\)</span> 式は偶然的・感染的原因による死亡のみに当てはまる。定数項をくわえて年齢とは独立して作用する死亡原因を考慮する。</p>
<p><span class="math display">\[
\mu (x) = \alpha \cdot e^{\beta x} + \gamma \tag{ns2}\label{eq:ns2}
\]</span></p>
<p><span class="math inline">\(\ref{eq:ns2}\)</span> 式は80歳以上では死亡率を課題に推計する可能性がある。そこで、ロジスティックモデルを推定して最高齢層の死亡率をあらわす。</p>
<p><span class="math display">\[
\mu (x) = \frac{\beta \gamma^x}{1 + \beta \gamma^x} \tag{ns3}
\]</span></p>
<p>死亡率の推定に使うと、<span class="math inline">\(\mu (x)\)</span>のロジットが年齢の線形の関数であることがわかる。</p>
<p><span class="math display">\[
1 - \mu (x) = \frac{1}{1 + \beta \gamma^x} \tag{ns4}
\]</span></p>
<p><span class="math display">\[
\frac{\mu (x)}{1 - \mu (x)} = \beta \gamma^x \tag{ns5}
\]</span></p>
<p>他方で若年層では年齢とともに死亡率は減る。幼児死亡率は内生的要素と事故や感染にもとづく外生的要素に分解できる。<span class="math inline">\(n\)</span>は年齢を、<span class="math inline">\(\ref{eq:ns6}\)</span> 式の第一項は内生的要素を、第二項は外生的要素を示す。</p>
<p><span class="math display">\[
q(n) = a + b [In (n + 1)]^3 \tag{ns6}\label{eq:ns6}
\]</span></p>
<p>最終的に全年齢の死亡をモデリングするには8つのパラメータが必要となる。第一項(<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>、<span class="math inline">\(C\)</span>、ただし<span class="math inline">\(C &lt; 0\)</span>)は若年期の死亡率を、第二項は青年期に見られる’accudent hump’を、第三項は高齢期のロジスティック式を表す(厳密には若年期・青年期・高齢期の定数項がそれぞれ必要ではないだろうか)。</p>
<p><span class="math display">\[
\frac{{}_1 q_x}{{}_1 p_x} = A^{(x+B)^C} + D e^{- E (In (x) - In (F))^2} + GH^x \tag{ns7}\label{eq:ns7}
\]</span></p>
<p><span class="math inline">\(\ref{eq:ns7}\)</span> 式のような普遍的なモデルは内生的な死亡にのみ当てはまり、人口によってばらつく特定の疾患については考慮できていない点に留意が必要。</p>
</section>
<section id="表による表現" class="level3" data-number="9.1.2">
<h3 data-number="9.1.2" class="anchored" data-anchor-id="表による表現"><span class="header-section-number">9.1.2</span> 表による表現</h3>
<p>表による表現では出生時の平均余命といった任意の死亡水準についての一般的な生命表関数をあらわす’モデル生命表’の形をとる。今日ではCoale and Demenyが1966年に作成したモデル生命表が使われる(けれども、現代的な統計のスタンダードとしては不十分)。地域と<span class="math inline">\(e^o_{10}\)</span>の値にもとづくモデル生命表は二重のエントリーシステムにもとづいている。</p>
<p>作成手続きは以下の通り。(1) 国勢調査の年齢で記録された人口と死亡の組み合わせに基づいて、男女326人づつの実際の死亡スケジュールを収集する。(2) それぞれの年齢での<span class="math inline">\({}_n q_x\)</span> をランクづけし、暫定的なモデル生命表を作成する。(3) そのモデル生命表と実際の生命表を比較し、その差異を年齢の関数として表現する。(4) 残りの192の表から地理的に分類される4つのクラスタ(東西南北)を析出する。</p>
<p>いくつか注意点がある。単一の年齢別死亡率から選択される生命表は、地域モデルの選択に非常に敏感であるため、死亡の年齢パターンについての独立した情報を必要とする<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。モデル生命表は<span class="math inline">\(e^o_{10}\)</span>の推計から<span class="math inline">\({}_n q_x\)</span>を推計するが、幼児死亡率から任意の年齢区間の死亡率を最もよく推定できる保証はない。実際のデータに含まれていない最高(最低)の死亡率レベルについては、パフォーマンスが良くない。因子分析を用いると死亡の一般的なレベル、幼少期から青年期までの死亡、極端な年齢の死亡の3つの要素から90％のばらつきを説明できる。</p>
<p>モデル生命表の限界は、先進国の実証データにもとづいて作成されているにもかかわらず、発展途上国にモデルを適用している点にある。</p>
</section>
<section id="関係モデル" class="level3" data-number="9.1.3">
<h3 data-number="9.1.3" class="anchored" data-anchor-id="関係モデル"><span class="header-section-number">9.1.3</span> 関係モデル</h3>
<p>関係モデルは、表形式で表現された「基準」死亡関数と、その関数をあらゆる集団の死亡率に関係づけるための数学的規則からなる。死亡の年齢パターンの複雑さを基準からとらえ、モデルパラメータから基準との偏差を捉える。結果的に、数学的に導出された死亡関数よりも少ないパラメータでモデリングできる利点を持つ。</p>
<p>最初のモデルは<span class="math inline">\(q(x)\)</span> (<span class="math inline">\(x\)</span>歳の前に死亡する確率)のロジット変換にもとづく。</p>
<p><span class="math display">\[
logit [q(x)] - \frac{1}{2} In \left[ \frac{q(x)}{1 - q(x)} \right] \tag{ns8}
\]</span></p>
<p><span class="math inline">\(q(x)\)</span> のロジット (<span class="math inline">\(Y(x)\)</span>)の予測値が求められれば、<span class="math inline">\(Y(x)\)</span>を逆変換して<span class="math inline">\(x\)</span>歳の前に死亡する<strong>予測</strong>確率を求められる。</p>
<p><span class="math display">\[
\hat{q}(x) = \frac{exp(2\hat{Y} (x))}{1 + exp(2\hat{Y} (x))} \tag{ns9}
\]</span></p>
<p>同じように、生まれてから<span class="math inline">\(x\)</span>歳まで生存する確率は<span class="math inline">\(1 - \hat{q}(x) = \hat{p}(x)\)</span>である。</p>
<p><span class="math display">\[
\hat{p}(x) = 1 - \hat{q} (x)  = \frac{1}{1 + exp(2\hat{Y} (x))} \tag{9.2}
\]</span></p>
<p>最終的に、<span class="math inline">\(Y(x)\)</span>を標準的な人口<span class="math inline">\(Y^S(x)\)</span>について予測する関係モデルは<span class="math inline">\(\ref{eq:9.3}\)</span> 式のようになる。<span class="math inline">\(\alpha\)</span>は死亡’レベル’(切片)を示す。<span class="math inline">\(\alpha\)</span>が大きくなると<span class="math inline">\(Y(x)\)</span>は全年齢で増加し<span class="math inline">\(p(x)\)</span>は全年齢で減少する。<span class="math inline">\(\alpha\)</span>が大きいと死亡率が高い。<span class="math inline">\(\beta\)</span>は死亡関数の’傾き’である。<span class="math inline">\(\beta\)</span>が大きくなると<span class="math inline">\(Y(x)\)</span>は<span class="math inline">\(Y^S(x)\)</span>が正の年齢では増加し、負の年齢では減少する。</p>
<p><span class="math display">\[
\hat{Y}(x) = \alpha + \beta \cdot Y^S (x) \tag{9.3}\label{eq:9.3}
\]</span></p>
<p><span class="math inline">\(\ref{eq:9.3}\)</span> 式はあらゆる標準として使えるため、特定の文脈下ではより適切なモデルがあるかもしれない。関係モデルがうまく機能するかどうかは関心となる人口のために選択された基準の適切さ、そして基準における死亡が同じ類型に属するほかの人口とどのように関係しているかを特定するルールの適切さで決まる。</p>
<p>Ewbank, Gomez de Leon and Stoto (1983) は、もとのロジット変換に<span class="math inline">\(\kappa\)</span>と<span class="math inline">\(\lambda\)</span>という2つのパラメータを追加した。<span class="math inline">\(\kappa\)</span>と<span class="math inline">\(\lambda\)</span>が0に近づくほど古典的なロジット変換に近づく。</p>
<p><span class="math display">\[
T^S (x) = \frac{\left( \frac{p^S (x)}{1 - p^S (x)} \right) - 1}{2 \kappa} \text{when } p^S (x) \geq 0.5 \tag{ns10}
\]</span></p>
<p><span class="math display">\[
T^S (x) = \frac{\left(1 - \frac{1 - p^S (x)}{p^S (x)} \right)^{\lambda}}{2 \lambda} \text{when } p^S (x) &lt; 0.5 \tag{ns11}
\]</span></p>
</section>
</section>
<section id="結婚の年齢パターン" class="level2" data-number="9.2">
<h2 data-number="9.2" class="anchored" data-anchor-id="結婚の年齢パターン"><span class="header-section-number">9.2</span> 結婚の年齢パターン</h2>
<p>結婚の年齢パターンを記述するうえでは関係的アプローチが最も有用。一方で結婚可能性および結婚年齢は人口によるばらつきが大きい<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。他方で、これまでに結婚した女性の結婚割合は彼女ら自身の結婚年齢の平均と標準偏差に比してとても類似している(?)。</p>
<p>CoaleとMcNeilは、婚姻率基準から、結婚年齢別に結婚した女性の分布の密度関数<span class="math inline">\(G(a)\)</span>(<span class="math inline">\(a\)</span>歳での既婚割合)を導き出す関係モデルを提案した。<span class="math inline">\(a_0\)</span>は結婚が始まる年齢(人口の1％が結婚している年齢)を、<span class="math inline">\(\kappa\)</span>は女性がどれだけ速く結婚するかの指標を、<span class="math inline">\(C\)</span>は最終的に結婚した割合の標準化因子をそれぞれ示している。</p>
<p><span class="math display">\[
G(a)  = C \cdot G^S \left( \frac{a - a_0}{\kappa} \right) \tag{9.4}
\]</span></p>
<p>初婚の標準的な密度は以下の形態を取る(らしい)<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>。<span class="math inline">\(\ref{eq:9.5}\)</span> 式を通じて、<span class="math inline">\(G(a)\)</span>の表化された値が得られる。</p>
<p><span class="math display">\[
g_S (x) = 0.19465 \text{ exp} \{ -0.174 (x - 6.06) - \text{exp} [-0.288 (x - 6.06)] \} \tag{9.5}\label{eq:9.5}
\]</span></p>
<p>平均初婚年齢は<span class="math inline">\(a_0\)</span>と<span class="math inline">\(\kappa\)</span>の関数として、初婚年齢の分散は<span class="math inline">\(\kappa\)</span>だけの関数として求められる(それぞれ<span class="math inline">\(\ref{eq:ns12}\)</span> 式、<span class="math inline">\(\ref{eq:ns13}\)</span> 式)。</p>
<p><span class="math display">\[
\mu = \int^\infty_0 a G(a)  da = \alpha_0 + 11.36 \kappa \tag{ns12}\label{eq:ns12}
\]</span></p>
<p><span class="math display">\[
\sigma^2 = \int^\infty_0 (a - \mu)^2 G(a)  da = + 43.34 \kappa^2 \tag{ns13}\label{eq:ns13}
\]</span></p>
<p><span class="math inline">\(\ref{eq:ns12}\)</span> 式、<span class="math inline">\(\ref{eq:ns13}\)</span> 式からもわかるように、関係モデルは結婚年齢の平均と分散という観点からも再定式化できる。結果的に、結婚年齢の平均と分散が分かればモデルにフィットできる。</p>
<p><span class="math inline">\(\ref{eq:9.5}\)</span> 式の二重の指数項は指数がほぼ等差数列(隣接する各項の差が等しい数列)である正規曲線と3つの指数の畳み込みの近似としても考えられる。3つの指数項は、結婚プロセスのさまざまな段階における待ち時間の分布を表していると考えられ、それぞれのリスクは一定である。例えば、第1項は結婚可能になってから最終的な配偶者と出会うまでの時間、第2項は出会ってから婚約するまでの時間、第3項は婚約してから結婚するまでの時間を表すかもしれない。</p>
</section>
<section id="出生の年齢パターン" class="level2" data-number="9.3">
<h2 data-number="9.3" class="anchored" data-anchor-id="出生の年齢パターン"><span class="header-section-number">9.3</span> 出生の年齢パターン</h2>
<p>結婚は出産の重要なプロセスであるため、婚姻の年齢パターンに結婚から妊娠の間の待機時間と妊娠時間を単純にくわえた初産の年齢分布を導出すれば良い。しかし、4つの指数項を持つ年齢パターンと3つの指数項を持つ年齢パターンとを区別することができなかったので、不完全に終わった。</p>
<p>より成功した試みは婚姻の関係モデルと2つの基準にもとづく結婚出生率(marital fertility)の組み合わせで出生スケジュールの関係モデルを導き出すもの。ここで<span class="math inline">\(r(a)\)</span>は年齢固有の結婚出生率を、<span class="math inline">\(G(a)\)</span>は<span class="math inline">\(a\)</span>歳での結婚割合をそれぞれ示す。</p>
<p><span class="math display">\[
f(a) = G(a) \cdot r(a) \tag{ns14}
\]</span></p>
<p>出産抑制が故意におこなわれない自然出生の研究にもとづいて、CoaleとTrussellは<span class="math inline">\(a\)</span>歳での結婚出生率の割合を<span class="math inline">\(r(a)\)</span>として<span class="math inline">\(\ref{eq:9.6}\)</span> 式に示した。<span class="math inline">\(n(a)\)</span>は自然出生スケジュール下での<span class="math inline">\(a\)</span>歳での有子割合、<span class="math inline">\(v(a)\)</span>は自然出生スケジュールとは区別される年齢パターンを、<span class="math inline">\(m\)</span>は自然出生スケジュールからの乖離の程度を、<span class="math inline">\(M\)</span>は年齢パターンに基づかない結婚出生率のレベルをそれぞれ示す。</p>
<p><span class="math display">\[
r(a) = M \cdot n(a) \cdot e^{m \cdot v(a)} \tag{9.6}\label{eq:9.6}
\]</span></p>
<p>実際のスケジュールは<span class="math inline">\(m\)</span>と<span class="math inline">\(M\)</span>を推定することで予測する。この2つを推定するもっとも簡単な方法として、OLSのような線形推定が挙げられる。<span class="math inline">\(\ref{eq:ns15}\)</span> 式は<span class="math inline">\(\ref{eq:9.6}\)</span> 式の対数変換である。<span class="math inline">\(\ref{eq:ns15}\)</span> 式はなんらかの出生コントロールが行われているかどうかを検出するために用いられることがある。より複雑なデータがあればイベントヒストリー分析やコホート・パリティ分析を用いることもできる。</p>
<p><span class="math display">\[
In \left( \frac{r(a)}{n(a)} \right) = In(M) + m \cdot v(a) \tag{ns15}\label{eq:ns15}
\]</span></p>
<p><span class="math inline">\(x\)</span>歳での出生率の変換である<span class="math inline">\(Y(x)\)</span>は<span class="math inline">\(x\)</span>歳での出生率<strong>基準</strong>の変換と線形に関連する。</p>
<p><span class="math display">\[
Y(x) = \alpha + \beta \cdot Y^S (x) \tag{ns16}
\]</span></p>
<p><span class="math inline">\(Y(x)\)</span>をロジットで示すという見地では、二重の対数で変換する方が望ましい。<span class="math inline">\(f(x)\)</span>は<span class="math inline">\(x\)</span>歳での累積出生率の比を示す。<span class="math inline">\(Y(x)\)</span>が<span class="math inline">\(\alpha\)</span>に近くなる点で<span class="math inline">\(Y^S\)</span>が24歳で0に近づくという出生率基準を設定することが推奨されている。</p>
<p><span class="math display">\[
Y(x) = In (- In [f(x)]) \tag{ns17}
\]</span></p>
<p>結婚出生率という見地からは年齢パターンだけでなく結婚期間のモデルも重要となる。Pageは<span class="math inline">\(a\)</span>歳での出生率、結婚期間<span class="math inline">\(d\)</span>、時間<span class="math inline">\(t\)</span>を時間—年効果、年齢効果、期間効果の積として表現した。<span class="math inline">\(R(a)\)</span>は自然出生スケジュール<span class="math inline">\(r(a)\)</span>で近似でき、<span class="math inline">\(D(d)\)</span>は指数関数<span class="math inline">\(\text{exp}(-\sigma d)\)</span>の形をとる。<span class="math inline">\(L(t)\)</span>は年次レベルの出生率を、<span class="math inline">\(\sigma\)</span>結婚中の出生率の急速な低下をそれぞれ示している。</p>
<p><span class="math display">\[
r(a, d, t) = L(t) R(a) D(d) \tag{ns18}
\]</span></p>
<p>時間の参照軸を落とすと、CoaleとTrussellの<span class="math inline">\(M\)</span>と<span class="math inline">\(m\)</span>からも表現できる(<span class="math inline">\(\ref{eq:9.6}\)</span> 式と<span class="math inline">\(\ref{eq:ns15}\)</span> 式を参照)。</p>
<div class="callout callout-style-simple callout-none no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><span class="math inline">\(r(\cdot, d)\)</span>の部分が<span class="math inline">\(\text{exp}[- \sigma d]\)</span>になるとして、<span class="math inline">\(r(a, \cdot)\)</span>の部分が<span class="math inline">\(Ln(a)\)</span>になるのはなぜ…？<span class="math inline">\(\ref{eq:9.6}\)</span> 式をみると<span class="math inline">\(L = M \cdot \text{ exp}[m v(a)]\)</span>が成り立つということ…？</p>
</div>
</div>
</div>
<p><span class="math display">\[
r(a, d) = L n(a) exp [-\sigma d] \tag{ns19}\label{eq:ns19}
\]</span></p>
<p>年齢固有の結婚出生率は年齢および結婚期間固有の出生率の重み付け平均となる。<span class="math inline">\(W^L (a, d)\)</span>は<span class="math inline">\(a\)</span>歳に<span class="math inline">\(d\)</span>年結婚している女性の数を示している。</p>
<p><span class="math display">\[
r(a) = \frac{\int^a_0 W^L (a, d) r(a, d) dd}{\int^a_0 W^L (a, d) dd} \tag{ns20}\label{eq:ns20}
\]</span></p>
<p><span class="math inline">\(\ref{eq:ns19}\)</span> 式を<span class="math inline">\(\ref{eq:ns20}\)</span> 式に代入。</p>
<p><span class="math display">\[
r(a) = L n(a) \frac{\int^a_0 W^L (a, d) e^{-\sigma d} dd}{\int^a_0 W^L (a, d) dd} \tag{9.7}
\]</span></p>
<p>平均値の定理により分子の積分は<span class="math inline">\(\ref{eq:ns22}\)</span> 式としても表現できる。<span class="math inline">\(d^{\star} (a)\)</span>は0から<span class="math inline">\(a\)</span>年の期間。</p>
<p><span class="math display">\[
exp [-\sigma d^{\star} (a)] \cdot \int^a_0 W^L (a, d) dd \tag{ns22}\label{eq:ns22}
\]</span></p>
<p>最終的に結婚期間を考慮した出生率は<span class="math inline">\(\ref{eq:9.8}\)</span> 式となる。<span class="math inline">\(\ref{eq:9.8}\)</span> 式から見て取れるように、<span class="math inline">\(-v(a)\)</span>は<span class="math inline">\(a\)</span>歳の女性の初婚からの’平均’期間の割合として解釈できる。</p>
<p><span class="math display">\[
r(a) = L n(a) exp [-\sigma d^{\star} (a)] \tag{9.8}\label{eq:9.8}
\]</span></p>
</section>
<section id="移動の年齢パターン" class="level2" data-number="9.4">
<h2 data-number="9.4" class="anchored" data-anchor-id="移動の年齢パターン"><span class="header-section-number">9.4</span> 移動の年齢パターン</h2>
<p>移動も進学や転職、引退で起こると考えると年齢パターンが存在する。移動は青年期に最も多く生起し、わずかに引退期にも生起する。RogerとCastroは移動モデルにたいして11個のパラメータを提起した。<span class="math inline">\(\alpha_1\)</span>は就労以前の下降率、<span class="math inline">\(\lambda_2\)</span>は就労中の上昇率、<span class="math inline">\(\alpha_2\)</span>は就労中の下降率、<span class="math inline">\(\lambda_3\)</span>は引退後の上昇率、<span class="math inline">\(\alpha_3\)</span>は引退後の下降率、<span class="math inline">\(x_l\)</span>は最も低いポイント、<span class="math inline">\(x_h\)</span>は最も高いポイント、<span class="math inline">\(x_r\)</span>は引退での最も高いポイント、<span class="math inline">\(x\)</span>は労働力んおいフォウ、<span class="math inline">\(A\)</span>は親の移動、<span class="math inline">\(B\)</span>はジャンプ、<span class="math inline">\(c\)</span>は定数項をそれぞれ示している。</p>
<div id="fig-elephant" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="fig/migration_schedule.png" class="img-fluid figure-img" style="width:90.0%"></p>
<figcaption class="figure-caption">Figure&nbsp;1: 移動スケジュールのモデル<br>出所）Rogers and Castro(1981: 6)</figcaption>
</figure>
</div>
<p>移動パターンを式で表すと以下のようになる。第一項は幼少期の移動率を、第二項は青年期の移動率を、第三項は引退期の移動率をそれぞれ示している。</p>
<p><span class="math display">\[\begin{eqnarray}
m(x) &amp;= a_1 \text{ exp} (\alpha_1 x) + a_2 \text{ exp} \{-\alpha_2 (x - \mu_2) \text{exp} [-\lambda_2 (x - \mu_2)]\} \\
&amp;+ a_3 \text{ exp} \{-\alpha_3 (x - \mu_3) \text{exp} [-\lambda_3 (x - \mu_3)]\} +c \tag{ns23}
\end{eqnarray}\]</span></p>
</section>
</section>
<section id="コメント" class="level1 unnumbered unlisted">
<h1 class="unnumbered unlisted">コメント</h1>
<ul>
<li><p>モデリングをする際の理論セットという意味でとても勉強になった。現実的には理論セットをそのまま適用するのではなく、理論セットと現実データのズレを踏まえて現実を理解する、というアプローチは重要であると考えた。</p></li>
<li><p>超恥ずかしいのですが、畳み込み(convolution)ってなんでしたっけ・・・複数の関数の積を取る、くらいにしか理解してません。</p></li>
</ul>
<!-- - 実際の人口を表現する方法なのでスプラインで学習すればいいのに・・・ -->
<!-- - 理論が帰納的に打ち立てられている印象。実際のデータを用いてモデルを構築することが重要である -->
</section>
<section id="データクオリティを評価する方法" class="level1" data-number="10">
<h1 data-number="10"><span class="header-section-number">10</span> データクオリティを評価する方法</h1>
<p>信頼に足る人口学的推計をするうえでは高クオリティのデータを用いるか誤差を検出し修正することが求められる。この点で誤差評価は重要な役割を果たす。誤差には人々やイベントの網羅性を示すカバレッジ誤差とデータに記録された情報の正確さを示すコンテント誤差がある。さらに、誤差を同定するアプローチもマッチング(統計学)と人口学の2つに分けられる。</p>
<div id="tbl-approach" class="anchored">
<table class="table">
<caption>Table&nbsp;1: 誤差の同定アプローチの分類</caption>
<tbody>
<tr class="odd">
<td>誤差のタイプ</td>
<td>アプローチのタイプ</td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>マッチング(統計学)</td>
<td>人口学</td>
</tr>
<tr class="odd">
<td>カバレッジ</td>
<td>1</td>
<td>2</td>
</tr>
<tr class="even">
<td>コンテント</td>
<td>3</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<section id="カバレッジ誤差を同定する統計学的手法" class="level2" data-number="10.1">
<h2 data-number="10.1" class="anchored" data-anchor-id="カバレッジ誤差を同定する統計学的手法"><span class="header-section-number">10.1</span> カバレッジ誤差を同定する統計学的手法</h2>
<p><a href="#tbl-approach">Table&nbsp;1</a> のセル1はデータソースの完全性をあるデータを別のデータとマッチングさせることで推定することを目指している。この手続きは二重記録システムと呼ばれる。</p>
<p>具体的な手続きを確認する。ある期間に登録システムに記録された出産を、同じ期間に出産した女性に質問した調査からの回顧的な報告と比較し、<a href="#tbl-matching">Table&nbsp;2</a> の結果が得られたとする。ここから20の報告が漏れていたこと(B)、空のセル<span class="math inline">\(D\)</span>は<span class="math inline">\(\frac{A}{B} = \frac{C}{D} \text{ then } D = \frac{C}{A} \cdot B = \frac{50}{100} \cdot 20 = 10\)</span>であることがわかる。最終的に、登録の完全性は<span class="math inline">\(\frac{100}{120} = 0.8333\)</span>であることが見て取れる。</p>
<div id="tbl-matching" class="anchored">
<table class="table">
<caption>Table&nbsp;2: 二重記録システムでの回答</caption>
<tbody>
<tr class="odd">
<td></td>
<td>調査での回答</td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>出産した</td>
<td>出産していない</td>
</tr>
<tr class="odd">
<td>登録している</td>
<td>100 (A)</td>
<td>50 (C)</td>
</tr>
<tr class="even">
<td>登録していない</td>
<td>20 (B)</td>
<td>(D)</td>
</tr>
</tbody>
</table>
</div>
<p>二重記録システムはあるデータソースにおける欠落確率と別のデータソースのそれとの相関がないことを仮定しているが、その仮定は現実的ではなく、むしろ相関がある(相関バイアス)。さらに、マッチが’正しい’ことを同定する難しさ、同じ時間と空間を比較していないことによる’out-of-scope’バイアスなどの問題により、マッチングはほとんど使われなくなった。</p>
</section>
<section id="コンテント誤差を同定する統計学的手法" class="level2" data-number="10.2">
<h2 data-number="10.2" class="anchored" data-anchor-id="コンテント誤差を同定する統計学的手法"><span class="header-section-number">10.2</span> コンテント誤差を同定する統計学的手法</h2>
<p>調査の中身にも誤差が含まれる。最たる例は年齢である。1985年または1980年に死亡したアフリカ系アメリカ人の高齢者の死亡時年齢は過小に報告されていた。人種分類においてもヒスパニックの位置付けなどで誤差が生じる。</p>
</section>
<section id="データクオリティを評価する人口学的手法" class="level2" data-number="10.3">
<h2 data-number="10.3" class="anchored" data-anchor-id="データクオリティを評価する人口学的手法"><span class="header-section-number">10.3</span> データクオリティを評価する人口学的手法</h2>
<section id="一貫性の検証" class="level3" data-number="10.3.1">
<h3 data-number="10.3.1" class="anchored" data-anchor-id="一貫性の検証"><span class="header-section-number">10.3.1</span> 一貫性の検証</h3>
<p>バランス方程式がすべて真値を測定しているとき、2回の国勢調査による総人口の変化は<span class="math inline">\(\ref{eq:10.1}\)</span> 式となる。データを使って真の値を推定したときにバランス方程式が成り立たなければ、結果として生じる「閉鎖の誤差」は、少なくともどちらかが誤った、あるいは互換性のないデータであることを示している。</p>
<p><span class="math display">\[
\Delta N = B - D + I - O \tag{10.1}\label{eq:10.1}
\]</span></p>
<p>最初の国勢調査において生存しているコホートの人口変化を適用して一貫性を検証することもある。</p>
<p><span class="math display">\[
\Delta N_c = - D_c + I_c - O_c \tag{10.2}\label{eq:10.2}
\]</span></p>
<p><span class="math inline">\(\ref{eq:10.2}\)</span> 式は応用的に<span class="math inline">\(t\)</span>から<span class="math inline">\(t+y\)</span>時点の死亡登録の一貫性を評価するためにも使われる。<span class="math inline">\(R_c\)</span>は実祖k酢荒れた人口と期待人口との比を、<span class="math inline">\(N_c(t)\)</span>は<span class="math inline">\(t\)</span>時点でのコホートサイズ、<span class="math inline">\(D_c\)</span>はコホートの国勢調査間の死亡数、<span class="math inline">\(I_c\)</span>はコホートの国勢調査間の流入数、<span class="math inline">\(O_c\)</span>はコホートの国勢調査間の流出数をそれぞれ示している。<span class="math inline">\(R_c\)</span>が1から乖離するほどカバレッジ誤差もしくはコンテント誤差が大きいことを示している。一般的に先進国では<span class="math inline">\(R_c\)</span>は高年齢で大きくなる(年齢の誤記が多くなるため)。</p>
<p><span class="math display">\[
R_c = \frac{N_c (t + y)}{N_c (t) - D_c + I_c - O_c} \tag{10.3}
\]</span></p>
<p>一貫性の検証を正確さの検証に変換するためには、(1) 1つ(以上)のデータをより信頼できるものとして「特権化」する方法と、(2) モデルを立ててそのパラメータを解く方法がある。以下それぞれ解説する。</p>
</section>
<section id="つ以上の推定値を特権化するデータ評価" class="level3" data-number="10.3.2">
<h3 data-number="10.3.2" class="anchored" data-anchor-id="つ以上の推定値を特権化するデータ評価"><span class="header-section-number">10.3.2</span> 1つ(以上)の推定値を特権化するデータ評価</h3>
<p>米国国勢調査では’人口学的分析’と呼ばれる、国勢調査ではないデータから得られた正しい出生数、死亡数、流出入数が既知という仮定にもとづく戦略を採用している。これらの推定値を国勢調査の情報と比較してカバレッジ誤差を推定する。あるコホートにおける真値は<span class="math inline">\(\ref{eq:10.4}\)</span> 式で表される。この手法はアフリカ系アメリカ人の推定には役に立つが、不法移民などでは未だ不確実性が大きい。</p>
<p><span class="math display">\[
\hat{N}_c = B_c - D_c + I_c - O_c \tag{10.4}\label{eq:10.4}
\]</span></p>
<p>’世代消滅法’は人口学的分析と考えを同じくするが、コホートの死亡を最低年齢からではなく最高年齢から数える方法。<span class="math inline">\(x\)</span>歳時点のコホートサイズを、そのコホートが消滅するまでに発生したすべての死亡を数えることによって<span class="math inline">\(\ref{eq:10.5}\)</span> 式のように推定する。<span class="math inline">\(D^{\star} (x + a, t + a)\)</span>は<span class="math inline">\(t+a\)</span>時点の<span class="math inline">\(x+a\)</span>歳での記録された死亡数を示す(このように、世代消滅法は死亡登録を特権化する)。この方法はとくに高齢期の死亡を推定するために役立つ。</p>
<p><span class="math display">\[
\hat{N} (x, t) = \int^{\infty}_0 D^{\star} (x + a, t + a) da \tag{10.5}\label{eq:10.5}
\]</span></p>
<p>variable-r方程式を用いることでコホートではなく年次の死亡人口を推定できる。<span class="math inline">\(r^{\star} (a, t)\)</span>によって年次死亡推定を修正する。もし人口がstationaryであれば、<span class="math inline">\(\ref{eq:10.6}\)</span> 式は<span class="math inline">\(\ref{eq:10.5}\)</span> 式と同じになる。<span class="math inline">\(\ref{eq:10.6}\)</span> 式は人口数よりも死亡登録の完全性を評価するために用いられる。</p>
<p><span class="math display">\[
\hat{N} (y, t) = \int^{\infty}_0 D^{\star} (x, t) e^{\int^x_y r^{\star} (a, t) da} dx \tag{10.6}\label{eq:10.6}
\]</span></p>
</section>
<section id="モデルを課してデータを評価修正する" class="level3" data-number="10.3.3">
<h3 data-number="10.3.3" class="anchored" data-anchor-id="モデルを課してデータを評価修正する"><span class="header-section-number">10.3.3</span> モデルを課してデータを評価・修正する</h3>
<section id="死亡登録の完全性の推定のためのbrass法" class="level4" data-number="10.3.3.1">
<h4 data-number="10.3.3.1" class="anchored" data-anchor-id="死亡登録の完全性の推定のためのbrass法"><span class="header-section-number">10.3.3.1</span> 死亡登録の完全性の推定のためのBrass法</h4>
<p>ある閉鎖人口について、<span class="math inline">\(\ref{eq:ns24}\)</span> 式を考える。<span class="math inline">\(r\)</span>、<span class="math inline">\(b\)</span>、<span class="math inline">\(d\)</span>はそれぞれ任意の年次における成長、出生、死亡を示している。</p>
<p><span class="math display">\[
r = b - d \tag{ns24}\label{eq:ns24}
\]</span></p>
<p><span class="math inline">\(\ref{eq:ns24}\)</span> 式は<span class="math inline">\(x\)</span>歳以上の人口にも当てはまる。<span class="math inline">\(b(x+)\)</span>は<span class="math inline">\(x\)</span>歳での出生率、すなわち1年間に<span class="math inline">\(x\)</span>歳に到達人が<span class="math inline">\(x\)</span>歳以上の総人口に占める割合を指している。</p>
<p><span class="math display">\[
r(x+) = b(x+) - d(x+) \tag{ns25}
\]</span></p>
<p><span class="math display">\[
b(x+) = r(x+) + d(x+) \tag{10.7}\label{eq:10.7}
\]</span></p>
<p><span class="math inline">\(b(x+)\)</span>は<span class="math inline">\(\ref{eq:10.8}\)</span> 式として実際のデータからも推定できる。</p>
<p><span class="math display">\[
b^{\star} (x, t) = \frac{N(x, t)}{N(x+, t)} = \frac{\frac{1}{10} ({}_5 N_{x-5} (t) + {}_5 N_{x} (t))}{\Sigma^{\text{max}}_{a=x, 5}{}_5 N_a (t)} \tag{10.8}\label{eq:10.8}
\]</span></p>
<p>(1)人口が定常である、(2)死亡登録が完全であるという仮定のもとで報告された死亡と真の死亡の比(<span class="math inline">\(\ref{eq:ns26}\)</span> 式における<span class="math inline">\(R\)</span>)は年齢で一定となり、<span class="math inline">\(x\)</span>歳以上での真の死亡率は<span class="math inline">\(\ref{eq:ns26}\)</span> 式となる。<span class="math inline">\(d^{\star} (x+)\)</span>は<span class="math inline">\(x\)</span>歳以上での報告された死亡数を示す。</p>
<p><span class="math display">\[
d(x+) = \frac{d^{\star} (x+)}{R} \tag{ns26}\label{eq:ns26}
\]</span></p>
<p><span class="math inline">\(\ref{eq:ns26}\)</span> 式を<span class="math inline">\(\ref{eq:10.7}\)</span> 式に当てはめて<span class="math inline">\(\ref{eq:10.9}\)</span> 式を得る。</p>
<p><span class="math display">\[
b^{\star} (x+) = r + \frac{1}{R} \cdot [d^{\star} (x+)] \tag{10.9}\label{eq:10.9}
\]</span></p>
<p>仮定が正しければ、<span class="math inline">\(\ref{eq:10.9}\)</span> 式はすべての年齢について成立し、<span class="math inline">\(d^{\star} (x+)\)</span>にたいする<span class="math inline">\(b^{\star} (x+)\)</span>のプロットは直線に沿うはずだが、現実には高年齢の部分や大きな変化が起こった場合ずれる。最終的に<span class="math inline">\(R\)</span>の推定値は過小に報告されるだろう。</p>
</section>
<section id="国勢調査間の生存から死亡登録の完全性を推定する方法" class="level4" data-number="10.3.3.2">
<h4 data-number="10.3.3.2" class="anchored" data-anchor-id="国勢調査間の生存から死亡登録の完全性を推定する方法"><span class="header-section-number">10.3.3.2</span> 国勢調査間の生存から死亡登録の完全性を推定する方法</h4>
<p>人口の定常性の仮定なしに死亡登録の完全性を推定する方法もある。2回目の国勢調査におけるコホートサイズを、1回目の国勢調査における同じコホートのサイズおよび死亡数に関連付ける。<span class="math inline">\(N_c(1)\)</span>、<span class="math inline">\(N_c(2)\)</span>はそれぞれあるコホートの1回目および2回目の国勢調査のサイズを、<span class="math inline">\(D_c\)</span>は国勢調査間でのコホートで発生した死亡数をそれぞれ示している。ここでは国勢調査間の相対的な完全性は年齢で一定と仮定している。</p>
<p><span class="math display">\[
N_c(2) = N_c(1) - D_c(1) \tag{10.10}\label{eq:10.10}
\]</span></p>
<p>1回目と2回目での真のコホーとサイズと報告されたコホートサイズの関係は<span class="math inline">\(\ref{eq:ns27}\)</span> 式、<span class="math inline">\(\ref{eq:ns28}\)</span> 式で示される。<span class="math inline">\(E(1)\)</span>、<span class="math inline">\(E(2)\)</span>はそれぞれ1回目と2回目の国勢調査の数え上げenumerationを示している。</p>
<p><span class="math display">\[
N_c (1)^{\star} = N_c (1) \cdot E(1) \tag{ns27}\label{eq:ns27}
\]</span></p>
<p><span class="math display">\[
N_c (2)^{\star} = N_c (2) \cdot E(2) \tag{ns28}\label{eq:ns28}
\]</span></p>
<p>同様に、真の死亡数と報告された死亡数の関係は<span class="math inline">\(\ref{eq:ns29}\)</span> 式で示される。<span class="math inline">\(R\)</span>は国勢調査間の死亡登録の完全性を示す。</p>
<p><span class="math display">\[
D^{\star}_c = D_c \cdot R \tag{ns29}\label{eq:ns29}
\]</span></p>
<p><span class="math inline">\(\ref{eq:10.10}\)</span> 式に代入して<span class="math inline">\(\ref{eq:10.11}\)</span> 式を得る。</p>
<p><span class="math display">\[
\frac{N^{\star}_c (1)}{E (1)} = \frac{N^{\star}_c (2)}{E(2)} + \frac{D^{\star}_c}{R} \tag{ns30}
\]</span></p>
<p><span class="math display">\[
\frac{N^{\star}_c (1)}{N^{\star}_c (2)} = \frac{E(1)}{E(2)} + \frac{E(1)}{R} + \frac{D^{\star}_c}{N^{\star}_c (2)} \tag{10.11}\label{eq:10.11}
\]</span></p>
<p><span class="math inline">\(\frac{E(1)}{E(2)}\)</span>および<span class="math inline">\(\frac{E(1)}{R}\)</span>は<span class="math inline">\(\frac{N^{\star}_c (1)}{N^{\star}_c (2)}\)</span>とという観測された値を用いたほかのコホートへの線形回帰で推定できる。最終的に得られた<span class="math inline">\(\frac{E(1)}{E(2)}\)</span>は2つの国勢調査の相対的な網羅性を、<span class="math inline">\(\frac{E(1)}{R}\)</span>は1回目の国勢調査と比較した死亡登録の網羅性をそれぞれ示している。</p>
<p>この方法はあくまでも最初の国勢調査との相対性を推定している。これは死亡推定にはおよそ問題ではないが、年齢の過大報告には敏感である。</p>
</section>
<section id="モデル生命表システムを用いた高齢期の死亡率の推定" class="level4" data-number="10.3.3.3">
<h4 data-number="10.3.3.3" class="anchored" data-anchor-id="モデル生命表システムを用いた高齢期の死亡率の推定"><span class="header-section-number">10.3.3.3</span> モデル生命表システムを用いた高齢期の死亡率の推定</h4>
<p>特定のモデル生命表を用いて死亡率のレベルを解くことで、誤記された死亡率にを修正できる。(1)任意の年齢以上の粗死亡率が真値である、国勢調査間の誤答割合が同じという仮定のもと、誤記がない一貫性の検証に用いることのできる最高年齢<span class="math inline">\(Y\)</span>を同定し、高年齢のモデル生命表システムを用いて<span class="math inline">\(Y\)</span>歳以上の死亡率をもとめる。</p>
<p><span class="math display">\[
DR_y = \frac{\int^{\infty}_Y N(a) \mu (a) da}{\int^{\infty}_Y N(a) da} \tag{10.12}\label{eq:10.12}
\]</span></p>
<p><span class="math inline">\(Y\)</span>歳以上では<span class="math inline">\(N(a)\)</span>は歪んでいると考えられるので、variable-<em>r</em>を用いた年齢分布方程式をに置き換える。</p>
<p><span class="math display">\[
N(a) = N(Y) e^{\int^a_Y r(x) dx}\frac{p(a)}{p(Y)} \tag{ns31}\label{eq:ns31}
\]</span></p>
<p>最終的に<span class="math inline">\(\ref{eq:10.13}\)</span> 式を得る。<span class="math inline">\(r(x)\)</span>は<span class="math inline">\(x\)</span>歳での報告された成長率、<span class="math inline">\(d(a)\)</span>は<span class="math inline">\(a\)</span>歳でのモデル生命表での死亡、<span class="math inline">\(p(a)\)</span>はモデル生命表での生存者数をそれぞれ示している。<span class="math inline">\(\ref{eq:10.13}\)</span> 式は報告された年齢別成長率および<span class="math inline">\(Y\)</span>歳以上の粗死亡率と一致するモデル生命表を選択するために使用される。モデル生命表システムの中で平均余命が延びると、右辺の値は左辺の粗死亡率の観測値と等しくなるまで減少する。</p>
<p><span class="math display">\[
DR_y = \frac{\int^{\infty}_Y e^{\int^a_Y r(x) dx} p(a) \mu (a) da}{\int^{\infty}_Y e^{\int^a_Y r(x) dx } p(a) da} = \frac{\int^{\infty}_Y e^{\int^a_Y r(x) dx} d(a) da}{\int^{\infty}_Y e^{\int^a_Y r(x) dx } p(a) da} \tag{10.13}\label{eq:10.13}
\]</span></p>
</section>
<section id="つ以上の国勢調査を用いる" class="level4" data-number="10.3.3.4">
<h4 data-number="10.3.3.4" class="anchored" data-anchor-id="つ以上の国勢調査を用いる"><span class="header-section-number">10.3.3.4</span> 3つ以上の国勢調査を用いる</h4>
<p>APCモデルを用いてコホートの真のサイズを推定する方法もある。この方法では国勢調査に初登場した時点でのコホートの真のサイズを推定し、その後初登場時の人口から国勢調査間の死亡数を減じ、純移動数をくわえることによって、コホートのサイズを再構築する。年齢固有の誤差が時代で一定、時代固有の誤差が年齢で一定という仮定のもと、報告された数と真値を<span class="math inline">\(\ref{eq:10.14}\)</span> 式のように関連づける。<span class="math inline">\(C_{it}\)</span>は<span class="math inline">\(t\)</span>時点の国勢調査でコホート<span class="math inline">\(i\)</span>に報告された人数を、<span class="math inline">\(X_{it}\)</span>は<span class="math inline">\(t\)</span>時点の国勢調査でコホート<span class="math inline">\(i\)</span>の真の人数を、<span class="math inline">\(\alpha_a\)</span>は<span class="math inline">\(a\)</span>歳での国勢調査のカバレッジの網羅性を、<span class="math inline">\(\tau_t\)</span>は<span class="math inline">\(t\)</span>時点での国勢調査のカバレッジの網羅性を、<span class="math inline">\(\epsilon_{it}\)</span>は年齢、時代、コホートで条件付けると平均0になる残差をそれぞれ示している。</p>
<p><span class="math display">\[
C_{it} = \alpha_a \tau_t X_{it} + \epsilon_{it} \tag{10.14}\label{eq:10.14}
\]</span></p>
<p>最初のコホートのサイズの推定値を真値<span class="math inline">\(\gamma_i\)</span>と最初から<span class="math inline">\(t\)</span>時点までの累積死亡数および純流出数<span class="math inline">\(D_{it}\)</span>と関連づけるために、<span class="math inline">\(\ref{eq:10.14}\)</span> 式の誤差項を最小化する<span class="math inline">\(\ref{eq:10.15}\)</span> 式を得る。</p>
<p><span class="math display">\[
Min \Sigma_i \Sigma_t (C_{it} - \alpha_a \tau_t (\gamma_i - D_{it}))^2 \tag{10.15}\label{eq:10.15}
\]</span></p>
<p>この方法は死亡登録が正確であるという仮定にもとづいているが、出生登録が正確である仮定は必要ではない。このほか複数回の国勢調査を用いる方法としてLuther and Retherford(1988)の方法なども挙げられる。</p>
</section>
</section>
</section>
</section>
<section id="コメント-1" class="level1 unnumbered unlisted">
<h1 class="unnumbered unlisted">コメント</h1>
<ul>
<li>一般的に国勢調査の方が社会調査データより信頼性があると思っていたのだが、発展途上国ではそうではない、というのはすこし意外だった。</li>
</ul>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>たとえば、マラリアによる死亡の年齢パターンは結核のそれと類似していることを利用して熱帯アフリカの死亡を検討する。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>アジアではほとんど全員が結婚するものの、ヨーロッパでは20％ほどが生涯未婚。初婚年齢はアジアやアフリカでは15歳未満も見られるものの、ヨーロッパでは25歳以上である、など。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><span class="math inline">\(x\)</span>は実年齢、<span class="math inline">\(a\)</span>は結婚年齢、という区別をしている、おそらく。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>